<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Spectrum Color Picker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
        }
        #colorWheel {
            cursor: crosshair;
        }
        #rgbValue {
            margin-top: 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="colorWheel" width="400" height="400"></canvas>
        <div id="rgbValue">RGB: 255, 0, 0</div>
    </div>

    <script>
        const canvas = document.getElementById('colorWheel');
        const ctx = canvas.getContext('2d');
        const rgbValue = document.getElementById('rgbValue');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 5;

        let isDragging = false;
        let currentColor = { r: 255, g: 0, b: 0 };
        let selectedX = centerX + radius;
        let selectedY = centerY;

        // Create an off-screen canvas for color calculations
        const offScreenCanvas = document.createElement('canvas');
        offScreenCanvas.width = canvas.width;
        offScreenCanvas.height = canvas.height;
        const offScreenCtx = offScreenCanvas.getContext('2d');

        function drawColorWheel() {
            // Draw on the off-screen canvas
            for (let x = 0; x < offScreenCanvas.width; x++) {
                for (let y = 0; y < offScreenCanvas.height; y++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= radius) {
                        const hue = (Math.atan2(dy, dx) + Math.PI) / (2 * Math.PI);
                        const saturation = distance / radius;
                        const rgb = HSVtoRGB(hue, saturation, 1);
                        offScreenCtx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                        offScreenCtx.fillRect(x, y, 1, 1);
                    }
                }
            }

            // Copy the off-screen canvas to the visible canvas
            ctx.drawImage(offScreenCanvas, 0, 0);
            drawSelector(selectedX, selectedY);
        }

        function HSVtoRGB(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }

            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function drawSelector(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.stroke();
        }

        function updateColor(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= radius) {
                selectedX = x;
                selectedY = y;
                const imageData = offScreenCtx.getImageData(x, y, 1, 1);
                currentColor = {
                    r: imageData.data[0],
                    g: imageData.data[1],
                    b: imageData.data[2]
                };
                updateRGBDisplay();
                drawColorWheel();
            }
        }

        function updateRGBDisplay() {
            rgbValue.textContent = `RGB: ${currentColor.r}, ${currentColor.g}, ${currentColor.b}`;
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            updateColor(e.offsetX, e.offsetY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                updateColor(e.offsetX, e.offsetY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Initial draw
        drawColorWheel();
        updateColor(selectedX, selectedY); // Start with red (hue 0)
    </script>
</body>
</html>
